const fs = require("fs");
const path = require("path");
const Hjson = require('hjson');


const auto_imports_section_regex = /(\/\/\s*AUTOGENERATED IMPORTS[^\n]+\n)([\s\S]*?)(\/\/\s*END AUTOGENERATED IMPORTS[^\n]+\n)/
const auto_switch_regex = /(\/\/\s*AUTOGENERATED SWITCH[^\n]+\n)([\s\S]*?)(\/\/\s*END AUTOGENERATED SWITCH[^\n]+\n)/

const toVariableName = (str) => {
  // Remove non-alphanumeric characters and convert to lower case
  
  str = str.replaceAll("_", "-")
  str = str.replaceAll(/[^a-zA-Z0-9\-]/g, '').toLowerCase();
  return str.split('-').map((word, index) => {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join('');
}

function generate_component_exports(directory) {
  const files = fs.readdirSync(directory);
  let components = []; // Elements are [componentName, componentPath, componentID, isInput, config]
  let import_strings = [],
      metadata_import_strings = [], 
      switch_strings_display = [], 
      switch_strings_input = [],
      editor_switch_strings_display = [], 
      editor_switch_strings_input = [],
      input_component_ids = [],
      display_component_ids = [],
      input_component_configs = {};
  

  files.forEach(file => {
    const filePath = path.join(directory, file);
    const stats = fs.statSync(filePath);
    
    if (stats.isDirectory()) {
      readTsxFiles(filePath); // Recurse if directory
    } else if (path.extname(file) === '.tsx') {
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      // console.log(file);
      // console.log(typeof fileContent);

      // const regex = /(export\s)(const\s)(METADATA)/;
      // const demo_regex = /(export\s+)(function\s+)(SKELETON)(\(\s*\{)([\s\S]*?)(\}\:)/
      const export_regex = /(export\s+)(default\s+)(function\s+)([a-zA-Z0-9\_]+)(\(\s*\{)([\s\S]*?)(\}\:)/
      const regex = /(export\s)(const\s)(METADATA)(\s*\:\s*componentMetaDataType)?(\s*\=\s*)(\{)([\s\S]*?)(\}\;)([\s*\n]+)/;
      const find_metadata = fileContent.match(regex);
      const find_export = fileContent.match(export_regex);
      // const find_demo = fileContent.match(demo_regex);

      const file_name = file.slice(0, -4);
      const component_name = toVariableName(file_name);

      const first_two_columns = component_name + (Array(40 - component_name.length).fill(" ").join("")) + ((find_metadata !== null)?"found":"not found")
      const first_three_columns = first_two_columns + (Array(60 -first_two_columns.length).fill(" ").join("")) + ((find_export !== null)?"found":"not found")
      // const first_four_columns = first_three_columns + (Array(80 -first_three_columns.length).fill(" ").join("")) + ((find_demo !== null)?"found":"not found")
      

      console.log(first_three_columns);
      let arguments = [];

      if (find_export) {
        const filter_comments = find_export[6].replaceAll(/\/\/([^\n]+)\n/g, "");
        const components = filter_comments.split(',').map((argument) => argument.trim()).filter((argument) => (argument !== '' && !argument.startsWith('//')));
        arguments = components;
      }

      let is_input = false

      if (find_metadata) {
        import_strings.push(`import ${component_name} from '@/${directory}/${file_name}';`);

        

        const metadata = Hjson.parse('{' + find_metadata[7] + '}');
        
        if (metadata.config !== undefined) {
          is_input = true;
        }

        let argument_strings = [];
        for (const argument of arguments) {
          switch (argument) {
            case 'configuration':
              argument_strings.push(
                                      (is_input) ?
                                      'configuration={info}' :
                                      'configuration={(info as displayMapping)}'
                                    );
              break;
            case 'toolchainState':
              argument_strings.push('toolchainState={toolchainState}');
              break;
            case 'entriesMap':
              argument_strings.push('entriesMap={getEffectiveConfig(info)}');
              break;
          }
        }

        const arg_strings_joined = argument_strings.join(' ');
        const switch_case = `case "${file_name}":\n  return (\n    <${component_name} ${arg_strings_joined}/>\n  );`.replaceAll(/^|\n/g, "\n    ");
        if (is_input) {
          switch_strings_input.push(switch_case);
          input_component_ids.push(file_name);
          input_component_configs[file_name] = metadata.config;
          // if (find_demo)
          editor_switch_strings_input.push([
            `case "${file_name}":\n  return (\n    `,
            `<${component_name} ${arg_strings_joined}/>\n  );`
          ].join("").replaceAll(/^|\n/g, "\n    "));
        } else {
          switch_strings_display.push(switch_case);
          display_component_ids.push(file_name);
          // if (find_demo)
          editor_switch_strings_display.push(`case "${file_name}":\n  return (\n    <${component_name} demo ${arg_strings_joined}/>\n  );`.replaceAll(/^|\n/g, "\n    "));
      
          // else 
        }
        
        metadata_import_strings.push(`import { METADATA as METADATA_${component_name} } from '@/${directory}/${file_name}';`);
        // if (find_demo) {
        // }

      }
    }
  });

  const switch_strings = [...switch_strings_display, ...switch_strings_input];
  const editor_switch_strings = [...editor_switch_strings_display, ...editor_switch_strings_input];

  // console.log(switch_strings.join("\n"));
  const display_union_type = "export type displayComponents = " + display_component_ids.map((id) => `"${id}"`).join(" | ") + ";";
  const input_union_type = "export type inputComponents = " + input_component_ids.map((id) => `"${id}"`).join(" | ") + ";";
  const display_components_const = "export const DISPLAY_COMPONENTS : displayComponents[] = [" + display_component_ids.map((id) => `"${id}"`).join(",") + "];"
  const input_components_const = "export const INPUT_COMPONENTS : inputComponents[] = [" + input_component_ids.map((id) => `"${id}"`).join(",") + "];"
  const input_components_config_string = [
    "export const INPUT_COMPONENT_FIELDS : {[key in inputComponents]: inputComponentConfig} = ",
    JSON.stringify(input_component_configs, null, 2),
    ";"
  ].join("");

  const type_file_generated = [
    "import { inputComponentConfig } from \"@/types/toolchain-interface\";\n",
    display_union_type,
    input_union_type,
    display_components_const,
    input_components_const,
    input_components_config_string
  ].join("\n");

  return [import_strings, metadata_import_strings, switch_strings, editor_switch_strings, type_file_generated];
}

// const COMPONENTS_DIRECTORY = 'components/toolchain_interface';
const COMPONENTS_DIRECTORY = 'toolchain_components';
const APP_DISPLAY_TEMPLATE = 'lib/toolchain-display-mappings-app-template.tsx';
const EDITOR_DISPLAY_TEMPLATE = 'lib/toolchain-display-mappings-editor-template.tsx';

const [import_strings, metadata_import_strings, switch_strings, editor_switch_strings, type_file_generated] = generate_component_exports(COMPONENTS_DIRECTORY);

const app_display_template = fs.readFileSync(APP_DISPLAY_TEMPLATE, 'utf-8');
const editor_display_template = fs.readFileSync(EDITOR_DISPLAY_TEMPLATE, 'utf-8');

const new_file_app_display = app_display_template.replace(auto_imports_section_regex, import_strings.join("\n")).replace(auto_switch_regex, switch_strings.join("\n"));
const new_file_editor_display = editor_display_template.replace(auto_imports_section_regex, import_strings.join("\n")).replace(auto_switch_regex, editor_switch_strings.join("\n"));

fs.mkdirSync("public/cache/toolchains", { recursive: true });

fs.writeFileSync("public/cache/toolchains/toolchain-app-mappings.tsx", new_file_app_display);
fs.writeFileSync("public/cache/toolchains/toolchain-editor-mappings.tsx", new_file_editor_display);
fs.writeFileSync("public/cache/toolchains/toolchain-component-types.tsx", type_file_generated);
