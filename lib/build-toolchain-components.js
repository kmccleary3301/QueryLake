const fs = require("fs");
const path = require("path");
const Hjson = require('hjson');


const auto_imports_section_regex = /(\/\/\s*AUTOGENERATED IMPORTS[^\n]+\n)([\s\S]*?)(\/\/\s*END AUTOGENERATED IMPORTS[^\n]+\n)/
const auto_switch_regex = /(\/\/\s*AUTOGENERATED SWITCH[^\n]+\n)([\s\S]*?)(\/\/\s*END AUTOGENERATED SWITCH[^\n]+\n)/

const toVariableName = (str) => {
  // Remove non-alphanumeric characters and convert to lower case
  
  str = str.replaceAll("_", "-")
  str = str.replaceAll(/[^a-zA-Z0-9\-]/g, '').toLowerCase();
  return str.split('-').map((word, index) => {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join('');
}

function generate_component_exports(directory) {
  const files = fs.readdirSync(directory);
  let components = []; // Elements are [componentName, componentPath, componentID, isInput, config]
  let import_strings = [], switch_strings_display = [], switch_strings_input = [];


  files.forEach(file => {
    const filePath = path.join(directory, file);
    const stats = fs.statSync(filePath);
    
    if (stats.isDirectory()) {
      readTsxFiles(filePath); // Recurse if directory
    } else if (path.extname(file) === '.tsx') {
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      // console.log(file);
      // console.log(typeof fileContent);

      // const regex = /(export\s)(const\s)(METADATA)/;
      const export_regex = /(export\s+)(default\s+)(function\s+)([a-zA-Z0-9\_]+)(\(\s*\{)([\s\S]*?)(\}\:)/
      const regex = /(export\s)(const\s)(METADATA)(\s*\:\s*componentMetaDataType)?(\s*\=\s*)(\{)([\s\S]*?)(\}\;)([\s*\n]+)/;
      const find_metadata = fileContent.match(regex);
      const find_export = fileContent.match(export_regex);

      const file_name = file.slice(0, -4);
      const component_name = toVariableName(file_name);

      const first_two_columns = component_name + (Array(40 - component_name.length).fill(" ").join("")) + ((find_metadata !== null)?"found":"not found")
      const first_three_columns = first_two_columns + (Array(60 -first_two_columns.length).fill(" ").join("")) + ((find_export !== null)?"found":"not found")
      
      console.log(first_three_columns);
      let arguments = [];

      if (find_export) {
        const filter_comments = find_export[6].replaceAll(/\/\/([^\n]+)\n/g, "");
        const components = filter_comments.split(',').map((argument) => argument.trim()).filter((argument) => (argument !== '' && !argument.startsWith('//')));
        arguments = components;
      }

      let is_input = false

      if (find_metadata) {
        import_strings.push(`import ${component_name}, { METADATA as METADATA_${component_name}} } from '@/${directory}/${file_name}';`);
        
        const metadata = Hjson.parse('{' + find_metadata[7] + '}');
        // console.log(JSON.stringify(metadata, null, 2));
        // if (metadata.config === undefined) {
        //   switch_strings_display.push(`  case "${file_name}":\n    return (\n      <${component_name} configuration={(info as displayMapping)} toolchainState={toolchainState}/>\n    );`);
        // } else {
        //   switch_strings_input.push(`  case "${file_name}":\n    return (\n      <${component_name} configuration={info}/>\n    );`);
        // }
        if (metadata.config !== undefined) {
          is_input = true;
        }

      }
      //  else {
      //   // switch_strings_display.push(`  case "${file_name}":\n    return (\n      <${component_name} configuration={(info as displayMapping)} toolchainState={toolchainState}/>\n    );`);
      // }

      let argument_strings = [];
      for (const argument of arguments) {
        switch (argument) {
          case 'configuration':
            argument_strings.push(
                                    (is_input) ?
                                    'configuration={info}' :
                                    'configuration={(info as displayMapping)}'
                                  );
            break;
          case 'toolchainState':
            argument_strings.push('toolchainState={toolchainState}');
            break;
          case 'entriesMap':
            argument_strings.push('entriesMap={getEffectiveConfig(info)}');
            break;
        }
      }

      const switch_case = `case "${file_name}":\n  return (\n    <${component_name} ${argument_strings.join(' ')}/>\n  );`.replaceAll(/^|\n/g, "\n    ");
      if (is_input) {
        switch_strings_input.push(switch_case);
      } else {
        switch_strings_display.push(switch_case);
      }

    }
  });

  const switch_strings = [...switch_strings_display, ...switch_strings_input];
  console.log(switch_strings.join("\n"));

  return [import_strings, switch_strings];
}

const COMPONENTS_DIRECTORY = 'components/toolchain_interface';
const APP_DISPLAY_TEMPLATE = 'components/toolchain_interface/AppDisplayTemplate.tsx';
const EDITOR_DISPLAY_TEMPLATE = 'components/toolchain_interface/AppInputTemplate.tsx';

const [import_strings, switch_strings] = generate_component_exports(COMPONENTS_DIRECTORY);

const app_display_template = fs.readFileSync(APP_DISPLAY_TEMPLATE, 'utf-8');
const editor_display_template = fs.readFileSync(EDITOR_DISPLAY_TEMPLATE, 'utf-8');

const new_file_app_display = app_display_template.replace(auto_imports_section_regex, import_strings.join("\n")).replace(auto_switch_regex, switch_strings.join("\n"));
const new_file_editor_display = editor_display_template.replace(auto_imports_section_regex, import_strings.join("\n")).replace(auto_switch_regex, switch_strings.join("\n"));

fs.mkdirSync("public/cache/toolchains", { recursive: true });

